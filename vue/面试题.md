## MVVM和MVC

*MVC*: MVC即model-view-controller（模型-视图-控制器）是项目的一种分层架构思想，它把复杂的业 

务逻辑，抽离为职能单一的小模块，每个模块看似相互独立，其实又各自有相互依赖关系。它的好处 

是：保证了模块的智能单一性，方便程序的开发、维护、耦合度低。 

MVVM：MVVM即 *Model-View-ViewModel*，(模型-视图-控制器)它是一种双向数据绑定的模式， 

用viewModel来建立起model数据层和view视图层的连接，数据改变会影响视图，视图改变会影响数据 

## vue双向绑定的原理

vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属 

性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 

具体步骤： 

第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 

getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 

第二步：compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每 

个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 

第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: 

1、在自身实例化时往属性订阅器(dep)里面添加自己 

2、自身必须有一个update()方法 

3、待属性变动dep.notice()通知时，能调用自身的 update() 方法，并触发Compile中绑定的回 

调，则功成身退。 

第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer 

来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和 

Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向 

绑定效果。

## vue的生命周期

vue 实例从创建到销毁的过程就是生命周期。 

程序员也就是从开始创建、初始化数据、编译模板、挂在 dom -> 渲染、更新 -> 渲染、准备销毁、销毁在 

等一系列过程 

vue的声明周期常见的主要分为4大阶段8大钩子函数 

另外三个生命周期函数不常用 

keep-alive 主要用于保留组件状态或避免重新渲染。 

activated只有在keep-alive 组件激活时调用。 

deactivated只有在keep-alive 组件停用时调用。 

errorCapured 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错 

误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传 

播。 

一、创建前 / 后 

在beforeCreate生命周期函数执行的时候，data和method 还没有初始化 

在created 生命周期函数执行的时候，data和method已经初始化完成 

二、渲染前/后 

在beforeMount 生命周期函数执行的时候，已经编译好了模版字符串、但还没有真正渲染到页面中去 

在mounted 生命周期函数执行的时候，已经渲染完，可以看到页面 

三、数据更新前/后 

在beforeUpdate生命周期函数执行的时候，已经可以拿到最新的数据，但还没渲染到视图中去。 

在updated生命周期函数执行的时候，已经把更新后的数据渲染到视图中去了。 

四、销毁前/后 

在beforeDestroy 生命周期函数执行的时候，实例进入准备销毁的阶段、此时data 、methods 、指令 

等还是可用状态 

在destroyed生命周期函数执行的时候，实例已经完成销毁、此时data 、methods 、指令等都不可用

## v-if 与 v-show

v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁 

和重建，操作的实际上是dom元素的创建或销毁。 

v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换 

它操作的是display:none/block属性。 

一般来说， v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地 

切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 

## v-for中的key

页面上的标签都对应具体的虚拟dom对象(虚拟dom就是js对象), 循环中 ,如果没有唯一key , 页面上删除 

一条标签, 由于并不知道删除的是那一条! 所以要把全部虚拟dom重新渲染, 如果知道key为x标签被删除 

掉, 只需要把渲染的dom为x的标签去掉即可

## 组件中的data为什么要定义成一个函数而不是一个对象？

每个组件都是 Vue 的实例。组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一 

个会影响其他

## **后台管理系统中的权限管理是怎么实现的？**

登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个**token**， 

拿到token之后（我会将这个token存贮到cookie中，保证刷新页面后能记住用户登录状态），前端会 

根据token再去拉取一个 **user_info** 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。 

权限验证：通过token获取用户对应的 权限，动态根据用户的 权限算出其对应有权限的路由，通过 

**router.addRoutes** 动态挂载这些路由。 

具体思路： 

登录成功后，服务端会返回一个 **token**（该token的是一个能唯一标示用户身份的一个key），之后我 

们将token存储在本地cookie之中，这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不 

用再去登录页面重新登录了。 

ps:为了保证安全性，我司现在后台所有token有效期(Expires/Max-Age)都是Session，就是当浏览器关 

闭了就丢失了。重新打开游览器都需要重新登录验证，后端也会在每周固定一个时间点重新刷新 

token，让后台用户全部重新登录一次，确保后台用户不会因为电脑遗失或者其它原因被人随意使用账 

号。 

用户登录成功之后，我们会在全局钩子 router.beforeEach 中拦截路由，判断是否已获得token，在 

获得token之后我们就要去获取用户的基本信息了 

页面会先从 cookie 中查看是否存有 token，没有，就走一遍上一部分的流程重新登录，如果有token, 

就会把这个 token 返给后端去拉取user_info，保证用户信息是最新的。 当然如果是做了单点登录得功 

能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新登 

录获取最新的内容。 

先说一说我权限控制的主体思路，前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登 

录之后，通过 **token** 获取用户的 **role** ，动态根据用户的 **role** 算出其对应有权限的路由，再通过 

router.addRoutes 动态挂载路由。但这些控制都只是页面级的，说白了前端再怎么做权限控制都不是 

绝对安全的，后端的权限验证是逃不掉的。 

我司现在就是前端来控制页面级的权限，不同权限的用户显示不同的侧边栏和限制其所能进入的页面(也 

做了少许按钮级别的权限控制)，后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每 

一个后台的请求不管是 get 还是 post 都会让前端在请求 header 里面携带用户的 **token**，后端会根据 

该 **token** 来验证用户是否有权限执行该操作。若没有权限则抛出一个对应的状态码，前端检测到该状 

态码，做出相对应的操作。 

使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。 

具体实现： 

创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页 

面。 

当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路 

由表。 

调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。 

使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。 





